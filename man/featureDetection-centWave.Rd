% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/DataClasses.R, R/functions-Params.R, R/methods-OnDiskMSnExp.R, R/methods-Params.R
\docType{class}
\name{featureDetection-centWave}
\alias{CentWaveParam}
\alias{CentWaveParam-class}
\alias{centWave}
\alias{detectFeatures,MSnExp,CentWaveParam-method}
\alias{detectFeatures,OnDiskMSnExp,CentWaveParam-method}
\alias{featureDetection-centWave}
\alias{firstBaselineCheck}
\alias{firstBaselineCheck,CentWaveParam-method}
\alias{firstBaselineCheck<-}
\alias{firstBaselineCheck<-,CentWaveParam-method}
\alias{fitgauss}
\alias{fitgauss,CentWaveParam-method}
\alias{fitgauss<-}
\alias{fitgauss<-,CentWaveParam-method}
\alias{integrate,CentWaveParam-method}
\alias{integrate<-}
\alias{integrate<-,CentWaveParam-method}
\alias{mzCenterFun}
\alias{mzCenterFun,CentWaveParam-method}
\alias{mzCenterFun<-}
\alias{mzCenterFun<-,CentWaveParam-method}
\alias{mzdiff}
\alias{mzdiff,CentWaveParam-method}
\alias{mzdiff<-}
\alias{mzdiff<-,CentWaveParam-method}
\alias{noise}
\alias{noise,CentWaveParam-method}
\alias{noise<-}
\alias{noise<-,CentWaveParam-method}
\alias{peakwidth}
\alias{peakwidth,CentWaveParam-method}
\alias{peakwidth<-}
\alias{peakwidth<-,CentWaveParam-method}
\alias{ppm}
\alias{ppm,CentWaveParam-method}
\alias{ppm<-}
\alias{ppm<-,CentWaveParam-method}
\alias{prefilter}
\alias{prefilter,CentWaveParam-method}
\alias{prefilter<-}
\alias{prefilter<-,CentWaveParam-method}
\alias{roiList}
\alias{roiList,CentWaveParam-method}
\alias{roiList<-}
\alias{roiList<-,CentWaveParam-method}
\alias{roiScales}
\alias{roiScales,CentWaveParam-method}
\alias{roiScales<-}
\alias{roiScales<-,CentWaveParam-method}
\alias{show,CentWaveParam-method}
\alias{snthresh}
\alias{snthresh,CentWaveParam-method}
\alias{snthresh<-}
\alias{snthresh<-,CentWaveParam-method}
\alias{verboseColumns}
\alias{verboseColumns,CentWaveParam-method}
\alias{verboseColumns<-}
\alias{verboseColumns<-,CentWaveParam-method}
\title{Feature detection using the centWave method}
\usage{
CentWaveParam(ppm = 25, peakwidth = c(20, 50), snthresh = 10,
  prefilter = c(3, 100), mzCenterFun = "wMean", integrate = 1L,
  mzdiff = -0.001, fitgauss = FALSE, noise = 0, verboseColumns = FALSE,
  roiList = list(), firstBaselineCheck = TRUE, roiScales = numeric())

\S4method{detectFeatures}{OnDiskMSnExp,CentWaveParam}(object, param,
  BPPARAM = bpparam(), return.type = "list")

\S4method{detectFeatures}{MSnExp,CentWaveParam}(object, param,
  BPPARAM = bpparam(), return.type = "list")

\S4method{show}{CentWaveParam}(object)

\S4method{ppm}{CentWaveParam}(object)

\S4method{ppm}{CentWaveParam}(object) <- value

\S4method{peakwidth}{CentWaveParam}(object)

\S4method{peakwidth}{CentWaveParam}(object) <- value

\S4method{snthresh}{CentWaveParam}(object)

\S4method{snthresh}{CentWaveParam}(object) <- value

\S4method{prefilter}{CentWaveParam}(object)

\S4method{prefilter}{CentWaveParam}(object) <- value

\S4method{mzCenterFun}{CentWaveParam}(object)

\S4method{mzCenterFun}{CentWaveParam}(object) <- value

\S4method{integrate}{CentWaveParam}(f)

\S4method{integrate}{CentWaveParam}(object) <- value

\S4method{mzdiff}{CentWaveParam}(object)

\S4method{mzdiff}{CentWaveParam}(object) <- value

\S4method{fitgauss}{CentWaveParam}(object)

\S4method{fitgauss}{CentWaveParam}(object) <- value

\S4method{noise}{CentWaveParam}(object)

\S4method{noise}{CentWaveParam}(object) <- value

\S4method{verboseColumns}{CentWaveParam}(object)

\S4method{verboseColumns}{CentWaveParam}(object) <- value

\S4method{roiList}{CentWaveParam}(object)

\S4method{roiList}{CentWaveParam}(object) <- value

\S4method{firstBaselineCheck}{CentWaveParam}(object)

\S4method{firstBaselineCheck}{CentWaveParam}(object) <- value

\S4method{roiScales}{CentWaveParam}(object)

\S4method{roiScales}{CentWaveParam}(object) <- value
}
\arguments{
\item{ppm}{Maximal tolerated m/z deviation in consecutive scans in parts
per million (ppm).}

\item{peakwidth}{Numeric of length 2 with the expected approximate
feature/peak width in chromatographic space. Given as a range (min, max)
in seconds.}

\item{snthresh}{Signal to noise ratio cutoff.}

\item{prefilter}{Numeric of length 2: \code{c(k, I)} specifying the prefilter
step for the first analysis step (ROI detection). Mass traces are only
retained if they contain at least \code{k} peaks with intensity \code{>= I}.}

\item{mzCenterFun}{Name of the function to calculate the m/z center of the
feature. Allowed are: \code{"wMean"}: intensity weighted mean of the feature's
m/z values, \code{"mean"}: mean of the feature's m/z values, \code{"apex"}:
use the m/z value at the peak apex, \code{"wMeanApex3"}: intensity weighted
mean of the m/z value at the peak apex and the m/z values left and right of
it and \code{"meanApex3"}: mean of the m/z value of the peak apex and the
m/z values left and right of it.}

\item{integrate}{Integration method. For \code{integrate = 1} peak limits
are found through descent on the mexican hat filtered data, for
\code{integrate = 2} the descent is done on the real data. The latter method
is more accurate but prone to noise, while the former is more robust, but
less exact.}

\item{mzdiff}{Numeric representing the minimum difference in m/z dimension
for peaks with overlapping retention times; can be negatove to allow overlap.}

\item{fitgauss}{Logical whether or not a Gaussian should be fitted to each
peak.}

\item{noise}{Numeric of length 1 allowing to set a minimum intensity required
for centroids to be considered in the first analysis step (centroids with
intensity \code{< noise} are omitted from ROI detection).}

\item{verboseColumns}{Logical whether additional feature meta data columns
should be returned.}

\item{roiList}{An optional list of regions-of-interest (ROI) representing
detected mass traces. If ROIs are submitted the first analysis step is
omitted and feature detection is performed on the submitted ROIs. Each
ROI object in the list is expected to have the following slots specified:
\code{scmin} (start scan index), \code{scmax} (end scan index),
\code{mzmin} (minimum m/z), \code{mzmax} (maximum m/z), \code{length}
(number of scans), \code{intensity} (summed intensity).}

\item{firstBaselineCheck}{Logical of length 1. If \code{TRUE} continuous
data within regions of interest is checked to be above the first baseline.}

\item{roiScales}{Optional numeric vector with length equal to \code{roiList}
defining the scale for each region of interest in \code{roiList} that should
be used for the centWave-wavelets.}

\item{object}{For \code{detectFeatures}: Either an
\code{\link[MSnbase]{OnDiskMSnExp}} or a \code{\link[MSnbase]{MSnExp}}
object containing the MS- and all other experiment-relevant data.

For all other methods: a parameter object.}

\item{param}{An \code{CentWaveParam} object containing all settings for the
centWave algorithm.}

\item{BPPARAM}{A parameter class specifying if and how parallel processing
should be performed. It defaults to \code{\link[BiocParallel]{bpparam}}.
See documentation of the \code{BiocParallel} for more details. If parallel
processing is enables, feature detection is performed in parallel on several
of the input samples.}

\item{return.type}{Character specifying what type of object the method should
return. Can be either \code{"list"} or \code{"xcmsSet"}.}

\item{value}{The value for the slot.}

\item{f}{For \code{integrate}: a \code{CentWaveParam} object.}
}
\value{
The \code{CentWaveParam} function returns a \code{CentWaveParam}
class instance with all of the settings specified for feature detection by
the centWave method.

For \code{detectFeatures}: if \code{return.type = "list"} a list of
length equal to the number of samples with matrices specifying the
identified features/peaks. If \code{return.type = "xcmsSet"} an
\code{\linkS4class{xcmsSet}} object with the results of the feature
detection.
}
\description{
The centWave algorithm perform peak density and wavelet based
feature detection for high resolution LC/MS data in centroid
mode [Tautenhahn 2008].

The \code{CentWaveParam} class allows to specify all settings for
a feature detection using the centWave method. Instances should be created
with the \code{CentWaveParam} constructor.

The \code{detectFeatures,OnDiskMSnExp,CentWaveParam} method
performs feature detection using the \emph{centWave} algorithm on all
samples from an \code{\link[MSnbase]{OnDiskMSnExp}} object.
\code{\link[MSnbase]{OnDiskMSnExp}} objects encapsule all experiment specific
data and load the spectra data (mz and intensity values) on the fly from the
original files applying also all eventual data manipulations.

The \code{detectFeatures,MSnExp,CentWaveParam} method performs
feature detection using the \emph{centWave} algorithm on all samples from
an \code{\link[MSnbase]{MSnExp}} object. These objects contain mz and
intensity values of all spectra hence no additional data input from the
original files is required.

\code{ppm},\code{ppm<-}: getter and setter for the \code{ppm}
slot of the object.

\code{peakwidth},\code{peakwidth<-}: getter and setter for the
\code{peakwidth} slot of the object.

\code{snthresh},\code{snthresh<-}: getter and setter for the
\code{snthresh} slot of the object.

\code{prefilter},\code{prefilter<-}: getter and setter for the
\code{prefilter} slot of the object.

\code{mzCenterFun},\code{mzCenterFun<-}: getter and setter for the
\code{mzCenterFun} slot of the object.

\code{integrate},\code{integrate<-}: getter and setter for the
\code{integrate} slot of the object.

\code{mzdiff},\code{mzdiff<-}: getter and setter for the
\code{mzdiff} slot of the object.

\code{fitgauss},\code{fitgauss<-}: getter and setter for the
\code{fitgauss} slot of the object.

\code{noise},\code{noise<-}: getter and setter for the
\code{noise} slot of the object.

\code{verboseColumns},\code{verboseColumns<-}: getter and
setter for the \code{verboseColumns} slot of the object.

\code{roiList},\code{roiList<-}: getter and setter for the
\code{roiList} slot of the object.

\code{fistBaselineCheck},\code{firstBaselineCheck<-}: getter
and setter for the \code{firstBaselineCheck} slot of the object.

\code{roiScales},\code{roiScales<-}: getter and setter for the
\code{roiScales} slot of the object.
}
\details{
The centWave algorithm is most suitable for high resolution
LC/\{TOF,OrbiTrap,FTICR\}-MS data in centroid mode. In the first phase the
method identifies \emph{regions of interest} (ROIs) representing mass traces
that are characterized as regions with less than \code{ppm} m/z deviation in
consecutive scans in the LC/MS map. These ROIs are then subsequently
analyzed using continuous wavelet transform (CWT) to locate chromatographic
peaks on different scales. The first analysis step is skipped, if regions
of interest are passed \emph{via} the \code{param} parameter.

Parallel processing (one process per sample) is supported and can
be configured either by the \code{BPPARAM} parameter or by globally defining
the parallel processing mode using the \code{\link[BiocParallel]{register}}
method from the \code{BiocParallel} package.
}
\section{Slots}{

\describe{
\item{\code{.__classVersion__,ppm,peakwidth,snthresh,prefilter,mzCenterFun,integrate,mzdiff,fitgauss,noise,verboseColumns,roiList,firstBaselineCheck,roiScales}}{See corresponding parameter above. \code{.__classVersion__} stores
the version from the class. Slots values should exclusively be accessed
\emph{via} the corresponding getter and setter methods listed above.}
}}
\note{
These methods and classes are part of the updated and modernized
\code{xcms} user interface which will eventually replace the
\code{\link{findPeaks}} methods. It supports feature detection on
\code{\link[MSnbase]{MSnExp}} and \code{\link[MSnbase]{OnDiskMSnExp}}
objects (both defined in the \code{MSnbase} package). All of the settings
to the centWave algorithm can be passed with a \code{CentWaveParam} object.
}
\examples{

## Create a CentWaveParam object
cwp <- CentWaveParam(ppm = 20)
## Change snthresh parameter
snthresh(cwp) <- 25
cwp

## Perform the feature detection using centWave on some of the files from the
## faahKO package. Files are read using the readMSData2 from the MSnbase
## package
library(faahKO)
library(MSnbase)
fls <- dir(system.file("cdf/KO", package = "faahKO"), recursive = TRUE,
           full.names = TRUE)
raw_data <- readMSData2(fls[1:2])

## Perform the feature detection using the settings defined above. We're
## returning the results as an xcmsSet object.
res <- detectFeatures(raw_data, param = cwp, return.type = "xcmsSet")
head(peaks(res))
}
\author{
Ralf Tautenhahn, Johannes Rainer
}
\references{
Ralf Tautenhahn, Christoph B\"{o}ttcher, and Steffen Neumann "Highly
sensitive feature detection for high resolution LC/MS" \emph{BMC Bioinformatics}
2008, 9:504
}
\seealso{
The \code{\link{do_detectFeatures_centWave}} core API function and
\code{\link{findPeaks.centWave}} for the old user interface.

Other feature detection methods: \code{\link{detectFeatures}},
  \code{\link{featureDetection-massifquant}},
  \code{\link{featureDetection-matchedFilter}}
}

