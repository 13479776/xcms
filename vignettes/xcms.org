#+TITLE: LCMS data preprocessing and analysis with =xcms= version 3
#+AUTHOR:    Johannes Rainer
#+EMAIL:     johannes.rainer@eurac.edu
#+DESCRIPTION:
#+KEYWORDS:
#+LANGUAGE:  en
#+OPTIONS: ^:{} toc:nil
#+PROPERTY: header-args :exports code
#+PROPERTY: header-args :session *R*

#+BEGIN_EXPORT html
---
title: "LCMS data preprocessing and analysis with xcms version 3"
graphics: yes
package: xcms
output:
  BiocStyle::html_document:
    toc_float: true
vignette: >
  %\VignetteIndexEntry{LCMS data preprocessing and analysis with xcms version 3}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
  %\VignetteDepends{xcms,RColorBrewer,faahKO,pander}
  %\VignettePackage{xcms}
  %\VignetteKeywords{mass spectrometry, metabolomics}
bibliography: xcms.bib
csl: biomed-central.csl
references:
- id: dummy
  title: no title
  author:
  - family: noname
    given: noname
---

#+END_EXPORT

#+BEGIN_EXPORT html
**Package**: `r Biocpkg("xcms")`<br />
**Authors**: Johannes Rainer<br />
**Modified**: `r file.info("xcms.Rmd")$mtime`<br />
**Compiled**: `r date()`
#+END_EXPORT

#+NAME: init
#+BEGIN_SRC R :ravel message = FALSE, echo = FALSE, results = "hide"
  ## Silently loading all packages
  library(BiocStyle)
  library(xcms)
  library(faahKO)
  library(pander)
  ## Use socket based parallel processing on Windows systems
  ## if (.Platform$OS.type == "unix") {
  ##     register(bpstart(MulticoreParam(2)))
  ## } else {
  ##     register(bpstart(SnowParam(2)))
  ## }
  register(SerialParam())
#+END_SRC

* Introduction

This documents describes data import, exploration, preprocessing and analysis of
LCMS experiments with =xcms= version 3. The examples and basic workflow was
adapted from the original /LC/MS Preprocessing and Analysis with xcms/ vignette
from Colin A. Smith.

* Data import

=xcms= supports analysis of LC/MS data from files in (AIA/ANDI) NetCDF, mzML/mzXML
and mzData format. For the actual data import Bioconductor's SRC_R[:exports
both]{Biocpkg("mzR")} is used. For demonstration purpose we will analyze a
subset of the data from \cite{Saghatelian04} in which the metabolic consequences
of knocking out the fatty acid amide hydrolase (FAAH) gene in mice was
investigated. The raw data files (in NetCDF format) are provided with the =faahKO=
data package. The data set consists of samples from the spinal cords of 6
knock-out and 6 wild-type mice. Each file contains data in centroid mode
acquired in positive ion mode form 200-600 m/z and 2500-4500 seconds.

Below we load all required packages, locate the raw CDF files within the =faahKO=
package and build a /phenodata/ data frame describing the experimental setup.

#+NAME: load-libs-pheno
#+BEGIN_SRC R :ravel message = FALSE
  library(xcms)
  library(faahKO)
  library(RColorBrewer)
  library(pander)

  ## Get the full path to the CDF files
  cdfs <- dir(system.file("cdf", package = "faahKO"), full.names = TRUE,
	      recursive = TRUE)
  ## Create a phenodata data.frame
  pd <- data.frame(sample_name = sub(basename(cdfs), pattern = ".CDF",
				     replacement = "", fixed = TRUE),
		   sample_group = c(rep("KO", 6), rep("WT", 6)),
		   stringsAsFactors = FALSE)
#+END_SRC

Subsequently we load the raw data as an =OnDiskMSnExp= object using the
=readMSData= method from the =MSnbase= package. While the =MSnbase= package was
originally developed for proteomics data processing, many of its functionality,
including raw data import and data representation, can be shared and reused in
metabolomics data analysis.

#+NAME: load-with-msnbase
#+BEGIN_SRC R :ravel message = FALSE
  raw_data <- readMSData(files = cdfs, pdata = new("NAnnotatedDataFrame", pd),
			 mode = "onDisk")
#+END_SRC

The =OnDiskMSnExp= object contains general information about the number of
spectra, retention times, the measured total ion current etc, but does not
contain the full raw data (i.e. the m/z and intensity values from each measured
spectrum). Its memory footprint is thus rather small making it an ideal object
to represent large metabolomics experiments while still allowing to perform
simple quality controls, data inspection and exploration as well as data
sub-setting operations. The m/z and intensity values are imported from the raw
data files on demand, hence the location of the raw data files should not be
changed after initial data import.

* Initial data inspection

The =OnDiskMSnExp= organizes the MS data by spectrum and provides the methods
=intensity=, =mz= and =rtime= to access the raw data from the files (the measured
intensity values, the corresponding m/z and retention time values). In addition,
the =spectra= method could be used to return all data encapsulated in =Spectrum=
classes. Below we extract the retention time values from the object.

#+NAME: data-inspection-rtime
#+BEGIN_SRC R :ravel message = FALSE
  head(rtime(raw_data))
#+END_SRC

All data is returned as one-dimensional vectors (a numeric vector for =rtime= and
a =list= of numeric vectors for =mz= and =intensity=, each containing the values from
one spectrum), even if the experiment consists of multiple files/samples. The
=fromFile= function returns a numeric vector that provides the mapping of the
values to the originating file. Below we use the =fromFile= indices to organize
the =mz= values by file.

#+NAME: data-inspection-mz
#+BEGIN_SRC R :ravel message = FALSE
  mzs <- mz(raw_data)

  ## Split the list by file
  mzs_by_file <- split(mzs, f = fromFile(raw_data))

  length(mzs_by_file)
#+END_SRC

As a first evaluation of the data we plot below the base peak chromatogram (BPC)
for each file in our experiment. We use the =chromatogram= method and set the
=aggregationFun= to ="max"= to return for each spectrum the maximal intensity and
hence create the BPC from the raw data. To create a total ion chromatogram we
could set =aggregationFun= to =sum=.

#+NAME: data-inspection-bpc
#+BEGIN_SRC R :ravel message = FALSE, fig.align = "center", fig.width = 8, fig.height = 4
  ## Get the base peak chromatograms. This reads data from the files.
  bpis <- chromatogram(raw_data, aggregationFun = "max")
  ## Define colors for the two groups
  group_colors <- brewer.pal(3, "Set1")[1:2]
  names(group_colors) <- c("KO", "WT")

  ## Plot all chromatograms.
  plot(bpis, col = group_colors[raw_data$sample_group])

#+END_SRC

The =chromatogram= method returned a =Chromatograms= object that organizes
individual =Chromatogram= objects (which in fact contain the chromatographic data)
in a two-dimensional array: columns represent samples and rows (optionally) m/z
and/or retention time ranges. Below we extract the chromatogram of the first
sample and access its retention time and intensity values.

#+NAME: data-inspection-chromatogram
#+BEGIN_SRC R :ravel message = FALSE
  bpi_1 <- bpis[1, 1]
  head(rtime(bpi_1))
  head(intensity(bpi_1))
#+END_SRC

The =chromatogram= method supports also extraction of chromatographic data from a
m/z-rt slice of the MS data. In the next section we will use this method to
create an extracted ion chromatogram (EIC) for a selected peak.

Note that =chromatogram= reads the raw data from each file to calculate the
chromatogram. The =bpi= and =tic= methods on the other hand do not read any data
from the raw files but use the respective information that was provided in the
header definition of the input files.

Below we create boxplots representing the distribution of total ion currents per
file. Such plots can be very useful to spot problematic or failing MS runs.

#+NAME: data-inspection-tic-boxplot
#+BEGIN_SRC R :ravel message = FALSE, fig.align = "center", fig.width = 8, fig.height = 4, fig.cap = "Distribution of total ion currents per file."
  ## Get the total ion current by file
  tc <- split(tic(raw_data), f = fromFile(raw_data))
  boxplot(tc, col = group_colors[raw_data$sample_group],
	  ylab = "intensity", main = "Total ion current")
#+END_SRC


* Chromatographic peak detection

Next we perform the chromatographic peak detection using the /centWave/ algorithm
\cite{Tautenhahn:2008fx}. Before running the peak detection it is however
strongly suggested to visually inspect e.g. the extracted ion chromatogram of
internal standards or known compounds to evaluate and adapt the peak detection
settings since the default settings will not be appropriate for most LCMS
experiments. The two most critical parameters for /centWave/ are the =peakwidth=
(expected range of chromatographic peak widths) and =ppm= (maximum expected
deviation of m/z values of centroids corresponding to one chromatographic peak;
this is usually much larger than the ppm specified by the manufacturer)
parameters.
To evaluate the typical chromatographic peak width we plot the EIC for one peak.

#+NAME: peak-detection-plot-eic
#+BEGIN_SRC R :ravel message = FALSE, fig.align = "center", fig.width = 8, fig.height = 5, fig.cap = "Extracted ion chromatogram for one peak."
  ## Define the rt and m/z range of the peak area
  rtr <- c(2700, 2900)
  mzr <- c(334.9, 335.1)
  ## extract the chromatogram
  chr_raw <- chromatogram(raw_data, mz = mzr, rt = rtr)
  plot(chr_raw, col = group_colors[chr_raw$sample_group])
#+END_SRC

The peak above has a width of about 50 seconds. The =peakwidth= parameter should
be set to accommodate the expected widths of peak in the data set. We set it to
=20,80= for the present example data set.

For the =ppm= parameter we extract the full MS data (intensity, retention time and
m/z values) corresponding to the above peak.

#+NAME: peak-detection-plot-ms-data
#+BEGIN_SRC R :ravel message = FALSE, fig.aligh = "center", fig.width = 7, fig.height = 7, fig.cap = "Visualization of the raw MS data for one peak. Upper panel: chromatogram plotting the intensity values against the retention time, lower panel m/z against retention time plot. The individual data points are colored according to the intensity."
  ## Extract the MS data for the region.
  msd_raw <- extractMsData(raw_data, mz = mzr, rt = rtr)
  plotMsData(msd_raw[[1]])
#+END_SRC

In the present data there is actually no variation in the m/z values. Usually
one would see the m/z values (lower panel) scatter around the /real/ m/z value of
the compound. It is suggested to inspect the ranges of m/z values for many
compounds (either internal standards or compounds known to be present in the
sample) and define the =ppm= parameter for /centWave/ according to these.

Below we perform the chromatographic peak detection using the =findChromPeaks=
method. The submitted /parameter/ object defines which algorithm will be used and
allows to define the settings for this algorithm. Note that we set the argument
=noise= to =1000= to slightly speed up the analysis by considering only signals with
a value larger than 1000 in the peak detection step.

#+NAME: peak-detection-centwave
#+BEGIN_SRC R :ravel message = FALSE, results = "hide"
  cwp <- CentWaveParam(peakwidth = c(30, 80), noise = 1000)
  xdata <- findChromPeaks(raw_data, param = cwp)
#+END_SRC

The results are returned as an =XCMSnExp= object which extends the =OnDiskMSnExp=
object by storing also LC/GC-MS preprocessing results. This means also that all
methods to sub-set and filter the data or to access the (raw) data are inherited
from the =OnDiskMSnExp= object. The results from the chromatographic peak
detection can be accessed with the =chromPeaks= method.

#+NAME: peak-detection-chromPeaks
#+BEGIN_SRC R :ravel message = FALSE
  head(chromPeaks(xdata))
#+END_SRC 

The returned =matrix= provides the m/z and retention time range for each
identified chromatographic peak as well as the integrated signal intensity
("into") and the maximal peak intensitity ("maxo"). Columns "sample" contains
the index of the sample in the object/experiment in which the peak was
identified.

Below we use the data from this table to calculate some per-file summaries.

#+NAME: peak-detection-peaks-per-sample
#+BEGIN_SRC R :ravel message = FALSE, results = "asis"
  summary_fun <- function(z) {
      c(peak_count = nrow(z), rt = quantile(z[, "rtmax"] - z[, "rtmin"]))
  }
  T <- lapply(split.data.frame(chromPeaks(xdata),
			       f = chromPeaks(xdata)[, "sample"]),
	      FUN = summary_fun)
  T <- do.call(rbind, T)
  rownames(T) <- basename(fileNames(xdata))
  pandoc.table(T,
	       caption = paste0("Summary statistics on identified chromatographic",
				" peaks. Shown are number of identified peaks per",
				" sample and widths/duration of chromatographic ",
				"peaks."))
#+END_SRC

We can also plot the location of the identified chromatographic peaks in the
m/z - retention time space for one file using the =plotChromPeaks= function. Below
we plot the chromatographic peaks for the 3rd sample.

#+NAME: peak-detection-chrom-peaks-plot
#+BEGIN_SRC R :ravel message = FALSE, fig.align = "center", fig.width = 5, fig.height = 5, fig.cap = "Identified chromatographic peaks in the m/z by retention time space for one sample."
  plotChromPeaks(xdata, file = 3)
#+END_SRC

To get a global overview of the peak detection we can plot the frequency of
identified peaks per file along the retention time axis. This allows to identify
time periods along the MS run in which a higher number of peaks was identified
and evaluate whether this is consistent across files.

#+NAME: peak-detection-chrom-peak-image
#+BEGIN_SRC R :ravel message = FALSE, fig.align = "center", fig.width = 7, fig.height = 5, fig.cap = "Frequency of identified chromatographic peaks along the retention time axis. The frequency is color coded with higher frequency being represented by yellow-white. Each line shows the peak frequency for one file."
  plotChromPeakImage(xdata)
#+END_SRC

Finally we highlight the identified chromatographic peaks for the example peak
from before. Evaluating such plots on a list of peaks corresponding to known
peaks or internal standards helps to ensure that peak detection settings were
appropriate and correctly identified the expected peaks.

#+NAME: peak-detection-highlight-chrom-peaks-plot
#+BEGIN_SRC R :ravel message = FALSE, fig.align = "center", fig.width = 7, fig.height = 5, fig.cap = "Signal for an example peak. Red and blue colors represent KO and wild type samples, respectively. The rectangles indicate the identified chromatographic peaks per sample."
  plot(chr_raw, col = group_colors[chr_raw$sample_group], lwd = 2)
  highlightChromPeaks(xdata, border = group_colors[chr_raw$sample_group], lty = 3,
		      rt = rtr, mz = mzr)
#+END_SRC

Note that we can also specifically extract identified chromatographic peaks for
a selected region by providing the respective m/z and retention time ranges with
the =mz= and =rt= arguments in the =chromPeaks= method.

#+NAME: peak-detection-chrom-peak-table-selected
#+BEGIN_SRC R :ravel message = FALSE, results = "asis"
  pander(chromPeaks(xdata, mz = mzr, rt = rtr),
	 caption = paste("Identified chromatographic peaks in a selected m/z and",
			 " retention time range."))
#+END_SRC

Finally we plot also the distribution of peak intensity per sample.

* Alignment

* Correspondence

* Further details and notes

+ See /new_functionality/ vignette.
+ Parallel processing set up.

* Details on chromatographic peak detection methods

** /matchedFilter/

The /matched filter/ method was originally described in 

** /centWave/

* TODOs                                                            :noexport:

** TODO General data import and data exploration section.
** TODO Feature detection section.
** TODO Sample alignment section.
** TODO Retention time correction section.
** TODO Describe methods more in detail in the appropriate section
